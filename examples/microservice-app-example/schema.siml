system {
  name: Example microservice app
  type: microservices
  domain: todo and authentication
  description: <<TEXT
Example polyglot microservice application: VueJS frontend, Go Auth API issuing JWT tokens, NodeJS Todos API with Redis-based log queue, Java Spring Boot Users API, Python log processor, Zipkin for tracing, Redis for queueing.
TEXT

  @PATH(docker-compose.yaml)
  runtime: {
    development: {
      backend: docker-compose
      services: [
        {
          name: frontend
          image: frontend
          build_context: ./frontend
          ports_exposed: [8080]
          depends_on: [zipkin, auth-api, todos-api, users-api]
          env: [PORT, AUTH_API_ADDRESS, TODOS_API_ADDRESS, ZIPKIN_URL]
        },
        {
          name: auth-api
          image: auth-api
          build_context: ./auth-api
          ports_exposed: [8081]
          depends_on: [zipkin, users-api]
          env: [AUTH_API_PORT, JWT_SECRET, USERS_API_ADDRESS, ZIPKIN_URL]
        },
        {
          name: todos-api
          image: todos-api
          build_context: ./todos-api
          ports_exposed: [8082]
          depends_on: [zipkin, redis-queue]
          env: [TODO_API_PORT, JWT_SECRET, REDIS_HOST, REDIS_PORT, REDIS_CHANNEL, ZIPKIN_URL]
        },
        {
          name: users-api
          image: users-api
          build_context: ./users-api
          ports_exposed: [8083]
          depends_on: [zipkin]
          env: [SERVER_PORT, JWT_SECRET, SPRING_ZIPKIN_BASE_URL]
        },
        {
          name: log-message-processor
          image: log-message-processor
          build_context: ./log-message-processor
          depends_on: [zipkin, redis-queue]
          env: [REDIS_HOST, REDIS_PORT, REDIS_CHANNEL, ZIPKIN_URL]
        },
        {
          name: zipkin
          image: openzipkin/zipkin
          ports_exposed: [9411]
        },
        {
          name: redis-queue
          image: redis
        }
      ]
    }

    @PATH(k8s/README.md)
    kubernetes: {
      backend: k8s
      cluster: minikube
      apply_command: kubectl create -R -f k8s/
      access: [
        {
          name: frontend
          command: minikube service frontend
        },
        {
          name: zipkin
          command: minikube service zipkin
        }
      ]
      build_instructions: <<TEXT
Start Minikube, connect Docker CLI to the Minikube node, and build images with docker-compose so they are available to the cluster.
Commands:
minikube start
eval $(minikube docker-env)
docker-compose build
TEXT
    }
  }

  @PATH(./frontend)
  @CALLS(system.auth_api)
  @CALLS(system.todos_api)
  @CALLS(system.users_api)
  @CALLS(system.zipkin)
  service frontend {
    description: <<TEXT
VueJS-based UI. Talks to Auth API for authentication, Todos API for CRUD operations, Users API for profiles. Emits tracing data to Zipkin when enabled.
TEXT
    langs: [javascript]
    dependencies: {
      auth_api: http client
      todos_api: http client
      users_api: http client
      zipkin: tracing collector
      node_packages: [vue-router, vuex, vue-resource, bootstrap-vue, bootstrap, jwt-decode, zipkin, zipkin-transport-http, zipkin-instrumentation-vue-resource]
    }
    runtime: {
      @PATH(./frontend/Dockerfile)
      development: {
        backend: docker-compose
        container_name: frontend
        build_context: ./frontend
        dockerfile: ./frontend/Dockerfile
        base_image: node:8-alpine
        port: 8080
        start_command: npm start
        tracing: zipkin
        env: [
          { key: PORT, value: 8080 },
          { key: AUTH_API_ADDRESS, value: auth-api:8081 },
          { key: TODOS_API_ADDRESS, value: todos-api:8082 },
          { key: ZIPKIN_URL, value: zipkin:9411/api/v2/spans }
        ]
      }

      @PATH(k8s/frontend/deployment.yaml)
      @PATH(k8s/frontend/service.yaml)
      kubernetes: {
        backend: k8s
        deployment_name: frontend
        service_name: frontend
        replicas: 1
        image: frontend
        image_pull_policy: Never
        labels: {
          app: microservice-app-example
          service: frontend
        }
        ports_exposed: [8080]
        service_type: LoadBalancer
        env: [
          { key: AUTH_API_ADDRESS, value: http://auth-api:8081 },
          { key: PORT, value: 8080 },
          { key: TODOS_API_ADDRESS, value: http://todos-api:8082 },
          { key: ZIPKIN_URL, value: http://zipkin:9411/api/v2/spans }
        ]
      }
    }
    components: [
      @PATH(./frontend/config/prod.env.js)
      config ProdEnv {
        NODE_ENV: production
      },
      @PATH(./frontend/config/dev.env.js)
      @BASE(system.frontend.components.ProdEnv)
      config DevEnv {
        NODE_ENV: development
      },
      @PATH(./frontend/config/index.js)
      config WebpackDevConfig {
        dev_server: webpack-dev-server
        port_source: env PORT
        auto_open_browser: false
        proxies: [
          {
            route: /login
            target_env: AUTH_API_ADDRESS
            fallback: http://127.0.0.1:8081
            secure: false
          },
          {
            route: /todos
            target_env: TODOS_API_ADDRESS
            fallback: http://127.0.0.1:8082
            secure: false
          },
          {
            route: /zipkin
            target_env: ZIPKIN_URL
            fallback: http://127.0.0.1:9411/api/v2/spans
            path_rewrite: {
              from: ^/zipkin
              to: empty
            }
            secure: false
          }
        ]
      },
      @PATH(./frontend/src/auth.js)
      struct AuthPlugin {
        methods: [
          +install(Vue any, options any) -> void,
          +login(creds any, redirect string?) -> Promise,
          +logout() -> void,
          +setAuthHeader(request any) -> void,
          +isAdmin() -> bool,
          +isLoggedIn() -> bool,
          -_retry(request any) -> Promise,
          -_storeToken(response any) -> void
        ]
      },
      @PATH(./frontend/src/zipkin.js)
      struct ZipkinPlugin {
        methods: [
          +install(Vue any, options any) -> void
        ]
      },
      @PATH(./frontend/src/main.js)
      struct FrontendApp {
        methods: [
          +bootstrap() -> void
        ]
      },
      @PATH(./frontend/src/components/App.vue)
      struct AppComponent {
      },
      @PATH(./frontend/src/components/AppNav.vue)
      struct AppNav {
        methods: [
          +logout() -> void,
          +isLoggedIn() -> bool,
          +isAdmin() -> bool
        ]
      },
      @PATH(./frontend/src/components/Login.vue)
      struct LoginView {
        methods: [
          +doLogin() -> void
        ]
      },
      @PATH(./frontend/src/components/TodoItem.vue)
      struct TodoItemComponent {
        fields: [
          +todo: any
        ]
      },
      @PATH(./frontend/src/components/Todos.vue)
      struct TodosView {
        fields: [
          +tasks: array_any,
          +isProcessing: bool,
          +errorMessage: string,
          +newTask: string
        ]
        methods: [
          +loadTasks() -> void,
          +addTask() -> void,
          +removeTask(index int) -> void,
          +total() -> int,
          +created() -> void
        ]
      },
      @PATH(./frontend/src/router/index.js)
      router FrontendRouter {
        library: vue-router
        routes: [
          {
            path: /login
            name: login
            component: LoginView
          },
          {
            path: /
            alias: /todos
            name: todos
            component: TodosView
            beforeEnter: requireLoggedIn
          }
        ]
        guards: [
          {
            name: requireLoggedIn
            trigger: beforeEnter
            check: Auth.isLoggedIn
            on_fail: redirect to /login with redirect query
          }
        ]
      },
      @PATH(./frontend/src/store/state.js)
      config StoreStorage {
        STORAGE_KEY: microservice-app-example-frontend
      },
      @PATH(./frontend/src/store/state.js)
      struct State {
        fields: [
          +auth: AuthState
          +user: UserState
        ]
      },
      @PATH(./frontend/src/store/state.js)
      struct AuthState {
        fields: [
          +isLoggedIn: bool
          +accessToken: string?
          +refreshToken: string?
        ]
      },
      @PATH(./frontend/src/store/state.js)
      struct UserState {
        fields: [
          +name: string?
          +role: any?
        ]
      },
      @PATH(./frontend/src/store/mutations.js)
      struct Mutations {
        methods: [
          +UPDATE_AUTH(state any, auth any) -> void,
          +UPDATE_USER(state any, user any) -> void,
          +CLEAR_ALL_DATA(state any) -> void
        ]
      },
      @PATH(./frontend/src/store/plugins.js)
      struct LocalStoragePlugin {
        methods: [
          +apply(store any) -> void,
          -_onMutation(mutation any, state any) -> void
        ]
      },
      @PATH(./frontend/src/store/index.js)
      struct VuexStore {
        fields: [
          +state: State
          +mutations: Mutations
          +plugins: array_any
        ]
      },
      @PATH(./frontend/src/components/common/Spinner.vue)
      struct SpinnerComponent {
        fields: [
          +message: string
        ]
      }
    ]
  }

  @PATH(./auth-api)
  @CALLS(system.users_api)
  @CALLS(system.zipkin)
  service auth_api {
    description: <<TEXT
Go-based authorization service issuing JWT tokens for use with other APIs. Uses Users API for profile data and Zipkin for tracing.
TEXT
    langs: [go]
    dependencies: {
      users_api: http client
      zipkin: tracing collector
    }
    runtime: {
      development: {
        backend: docker-compose
        container_name: auth-api
        port: 8081
        secrets: [JWT_SECRET]
        env: [
          { key: AUTH_API_PORT, value: 8081 },
          { key: USERS_API_ADDRESS, value: users-api:8083 },
          { key: ZIPKIN_URL, value: zipkin:9411/api/v2/spans }
        ]
      }

      @PATH(k8s/auth-api/deployment.yaml)
      @PATH(k8s/auth-api/service.yaml)
      kubernetes: {
        backend: k8s
        deployment_name: auth-api
        service_name: auth-api
        replicas: 1
        image: auth-api
        image_pull_policy: Never
        labels: {
          app: microservice-app-example
          service: auth-api
        }
        ports_exposed: [8081]
        env: [
          { key: AUTH_API_PORT, value: 8081 },
          { key: JWT_SECRET, value: myfancysecret },
          { key: USERS_API_ADDRESS, value: http://users-api:8083 },
          { key: ZIPKIN_URL, value: http://zipkin:9411/api/v2/spans }
        ]
      }
    }
    api: [
      {
        type: http
        endpoints: [
          GET /version -> TEXT{text: str} [auth: none],
          POST /login JSON{username: str, password: str} -> JSON{accessToken: str, error: str?} [auth: none]
        ]
      }
    ]
    components: [
      @PATH(./auth-api/user.go)
      interface HTTPDoer {
        methods: [
          +Do(req *http.Request) -> (*http.Response, error)
        ]
      },
      @PATH(./auth-api/user.go)
      struct UserService {
        fields: [
          +Client: HTTPDoer
          +UserAPIAddress: string
          +AllowedUserHashes: map_any
        ]
        methods: [
          +Login(ctx context.Context, username string, password string) -> (User, error),
          -getUser(ctx context.Context, username string) -> (User, error),
          -getUserAPIToken(username string) -> (string, error)
        ]
      },
      @PATH(./auth-api/user.go)
      struct User {
        fields: [
          +Username: string
          +FirstName: string
          +LastName: string
          +Role: string
        ]
      },
      @PATH(./auth-api/main.go)
      struct LoginRequest {
        fields: [
          +Username: string
          +Password: string
        ]
      },
      @PATH(./auth-api/tracing.go)
      struct TracedClient {
        fields: [
          -client: zipkinhttp.Client
        ]
        methods: [
          +Do(req *http.Request) -> (*http.Response, error)
        ]
      }
    ]
  }

  @PATH(./todos-api)
  @CALLS(system.redis_queue)
  @CALLS(system.zipkin)
  service todos_api {
    description: <<TEXT
NodeJS Todos API providing CRUD for user todo records. Publishes create and delete operations to a Redis channel for asynchronous logging. Emits traces to Zipkin.
TEXT
    langs: [nodejs]
    @PATH(./todos-api/package.json)
    dependencies: {
      redis_queue: publish log messages
      zipkin: tracing collector
      node_packages: [body-parser@^1.18.2, express@^4.15.4, express-jwt@^5.3.0, memory-cache@^0.2.0, redis@^2.8.0, zipkin@^0.11.2, zipkin-context-cls@^0.11.0, zipkin-instrumentation-express@^0.11.2, zipkin-transport-http@^0.11.2]
      node_dev_packages: [nodemon@^1.11.0]
    }
    runtime: {
      @PATH(./todos-api/Dockerfile)
      development: {
        backend: docker-compose
        container_name: todos-api
        build_context: ./todos-api
        dockerfile: ./todos-api/Dockerfile
        base_image: node:8-alpine
        port: 8082
        start_command: npm start
        secrets: [JWT_SECRET]
        env: [
          { key: TODO_API_PORT, value: 8082 },
          { key: REDIS_HOST, value: redis-queue },
          { key: REDIS_PORT, value: 6379 },
          { key: REDIS_CHANNEL, value: log_channel },
          { key: ZIPKIN_URL, value: zipkin:9411/api/v2/spans }
        ]
      }

      @PATH(k8s/todos-api/deployment.yaml)
      @PATH(k8s/todos-api/service.yaml)
      kubernetes: {
        backend: k8s
        deployment_name: todos-api
        service_name: todos-api
        replicas: 1
        image: todos-api
        image_pull_policy: Never
        labels: {
          app: microservice-app-example
          service: todos-api
        }
        ports_exposed: [8082]
        env: [
          { key: JWT_SECRET, value: myfancysecret },
          { key: TODO_API_PORT, value: 8082 },
          { key: REDIS_HOST, value: redis-queue },
          { key: REDIS_PORT, value: 6379 },
          { key: REDIS_CHANNEL, value: log_channel },
          { key: ZIPKIN_URL, value: http://zipkin:9411/api/v2/spans }
        ]
      }
    }
    api: [
      @PATH(./todos-api/routes.js)
      {
        type: http
        endpoints: [
          GET /todos -> JSON{items: map<int, Todo>} [auth: bearer_jwt],
          POST /todos JSON{content: str} -> JSON{todo: Todo} [auth: bearer_jwt],
          DELETE /todos/{taskId} -> void [auth: bearer_jwt, status: 204]
        ]
      }
    ]
    components: [
      queue TodosLogChannel {
        engine: redis
        channel: log_channel
        direction: publish
        purpose: publish create and delete event messages for logging
      },
      @PATH(./todos-api/todoController.js)
      struct TodoController {
        fields: [
          -_tracer: any
          -_redisClient: any
          -_logChannel: string
        ]
        methods: [
          +list(req any, res any) -> void,
          +create(req any, res any) -> void,
          +delete(req any, res any) -> void,
          -_logOperation(opName string, username string, todoId any) -> void,
          -_getTodoData(userID any) -> any,
          -_setTodoData(userID any, data any) -> void
        ]
      },
      @PATH(./todos-api/todoController.js)
      struct Todo {
        fields: [
          +id: int
          +content: string
        ]
      },
      @PATH(./todos-api/todoController.js)
      struct LogMessage {
        fields: [
          +opName: string
          +username: string
          +todoId: any
          +zipkinSpan: any
        ]
      }
    ]
  }

  @PATH(./users-api)
  @CALLS(system.zipkin)
  service users_api {
    description: <<TEXT
Java Spring Boot Users API providing user profiles (single user and list).
TEXT
    langs: [java]
    @PATH(./users-api/pom.xml)
    dependencies: {
      zipkin: tracing collector
      maven_dependencies: [org.springframework.boot:spring-boot-starter-web, org.springframework.boot:spring-boot-starter-security, io.jsonwebtoken:jjwt@0.7.0, org.springframework.boot:spring-boot-starter-data-jpa, com.h2database:h2, org.springframework.cloud:spring-cloud-starter-zipkin@1.3.1.RELEASE, org.springframework.boot:spring-boot-starter-test]
    }
    runtime: {
      @PATH(./users-api/Dockerfile)
      development: {
        backend: docker-compose
        container_name: users-api
        build_context: ./users-api
        dockerfile: ./users-api/Dockerfile
        base_image: openjdk:8-alpine
        port: 8083
        start_command: java -jar ./target/users-api-0.0.1-SNAPSHOT.jar
        secrets: [JWT_SECRET]
        env: [
          { key: SERVER_PORT, value: 8083 },
          { key: SPRING_ZIPKIN_BASE_URL, value: zipkin:9411 }
        ]
      }

      @PATH(k8s/users-api/deployment.yaml)
      @PATH(k8s/users-api/service.yaml)
      kubernetes: {
        backend: k8s
        deployment_name: users-api
        service_name: users-api
        replicas: 1
        image: users-api
        image_pull_policy: Never
        labels: {
          app: microservice-app-example
          service: users-api
        }
        ports_exposed: [8083]
        env: [
          { key: JWT_SECRET, value: myfancysecret },
          { key: SERVER_PORT, value: 8083 },
          { key: SPRING_ZIPKIN_BASE_URL, value: http://zipkin:9411 }
        ]
      }
    }
    api: [
      @PATH(./users-api/README.md)
      @PATH(users-api/src/main/java/com/elgris/usersapi/api/UsersController.java)
      {
        type: http
        endpoints: [
          GET /users -> JSON{users: any},
          GET /users/{username} -> JSON{user: any?} [auth: bearer_jwt, access_control: same_user]
        ]
      }
    ]
    components: [
      @PATH(./users-api/.mvn/wrapper/maven-wrapper.properties)
      config MavenWrapper {
        distribution_url: https://repo1.maven.org/maven2/org/apache/maven/apache-maven/3.5.0/apache-maven-3.5.0-bin.zip
      },
      @PATH(users-api/src/main/resources/application.properties)
      config ApplicationProperties {
        jwt.secret: myfancysecret
        server.port: 8083
        spring.application.name: users-api
        spring.zipkin.baseUrl: http://127.0.0.1:9411/
        spring.sleuth.sampler.percentage: 100.0
      },
      @PATH(users-api/src/main/java/com/elgris/usersapi/configuration/SecurityConfiguration.java)
      struct HttpSecurityConfiguration {
        web_security_enabled: true
        global_method_security_secured_enabled: true
      },
      @PATH(users-api/src/main/java/com/elgris/usersapi/configuration/SecurityConfiguration.java)
      struct ApiConfigurerAdatper {
        extends: WebSecurityConfigurerAdapter
        fields: [
          -jwtAuthenticationFilter: JwtAuthenticationFilter
        ]
        methods: [
          +configure(http HttpSecurity) -> void {
            description: Configures HttpSecurity to match all paths and adds JwtAuthenticationFilter after BasicAuthenticationFilter
          }
        ]
      },
      database UsersDB {
        engine: h2
        description: In-memory H2 database managed by Spring Data JPA and seeded via data.sql
        components: [
          table users {
            username: VARCHAR
            firstname: VARCHAR
            lastname: VARCHAR
            role: INT
          }
        ]
      },
      @PATH(users-api/src/main/resources/data.sql)
      sql InitialData {
        target: users table
        statements: <<TEXT
INSERT INTO users (username, firstname, lastname, role) VALUES
  ('admin', 'Foo', 'Bar', 1),
  ('johnd', 'John', 'Doe', 0),
  ('janed', 'Jane', 'Doe', 0);
TEXT
      },
      @PATH(users-api/src/main/java/com/elgris/usersapi/UsersApiApplication.java)
      struct UsersApiApplication {
        methods: [
          +main(args string[]) -> void
        ]
      },
      @PATH(users-api/src/test/java/com/elgris/usersapi/UsersApiApplicationTests.java)
      struct UsersApiApplicationTests {
        methods: [
          +contextLoads() -> void
        ]
      },
      @PATH(users-api/src/main/java/com/elgris/usersapi/api/UsersController.java)
      struct UsersController {
        fields: [
          -userRepository: UserRepository
        ]
        methods: [
          +getUsers() -> User[],
          +getUser(request any, username string) -> User
        ]
      },
      @PATH(users-api/src/main/java/com/elgris/usersapi/repository/UserRepository.java)
      interface UserRepository {
        extends: CrudRepository
        entity: User
        id_type: Long
        methods: [
          +findOneByUsername(username string) -> User,
          +findByUsername(username string) -> User,
          +getByUsername(username string) -> User
        ]
      },
      @PATH(users-api/src/main/java/com/elgris/usersapi/models/User.java)
      struct User {
        fields: [
          +username: string
          +firstname: string
          +lastname: string
          +role: UserRole
        ]
      },
      @PATH(users-api/src/main/java/com/elgris/usersapi/models/UserRole.java)
      enum UserRole {
        values: [USER, ADMIN]
        description_field: description
      },
      @PATH(users-api/src/main/java/com/elgris/usersapi/security/JwtAuthenticationFilter.java)
      struct JwtAuthenticationFilter {
        extends: GenericFilterBean
        fields: [
          -jwtSecret: string
        ]
        methods: [
          +doFilter(req ServletRequest, res ServletResponse, chain FilterChain) -> void
        ]
      },
      @PATH(users-api/src/main/java/com/elgris/usersapi/security/AccessUserFilter.java)
      struct AccessUserFilter {
        extends: GenericFilterBean
        methods: [
          +doFilter(req ServletRequest, res ServletResponse, chain FilterChain) -> void
        ]
      }
    ]
  }

  @PATH(./log-message-processor)
  @CALLS(system.redis_queue)
  @CALLS(system.zipkin)
  service log_message_processor {
    description: <<TEXT
Python worker that consumes messages from Redis channel and prints them to stdout. Used for logging of Todos API operations. Emits traces to Zipkin.
TEXT
    langs: [python]
    @PATH(./log-message-processor/requirements.txt)
    dependencies: {
      redis_queue: subscribe log messages
      zipkin: tracing collector
      python_packages: [redis==2.10.6, py_zipkin==0.11.0, requests]
    }
    runtime: {
      @PATH(./log-message-processor/Dockerfile)
      development: {
        backend: docker-compose
        container_name: log-message-processor
        build_context: ./log-message-processor
        dockerfile: ./log-message-processor/Dockerfile
        base_image: python:3.6-alpine
        start_command: python3 -u main.py
        env: [
          { key: REDIS_HOST, value: redis-queue },
          { key: REDIS_PORT, value: 6379 },
          { key: REDIS_CHANNEL, value: log_channel },
          { key: ZIPKIN_URL, value: zipkin:9411/api/v1/spans }
        ]
      }

      @PATH(k8s/log-message-processor/deployment.yaml)
      kubernetes: {
        backend: k8s
        deployment_name: log-message-processor
        replicas: 1
        image: log-message-processor
        image_pull_policy: Never
        labels: {
          app: microservice-app-example
          service: log-message-processor
        }
        env: [
          { key: REDIS_HOST, value: redis-queue },
          { key: REDIS_PORT, value: 6379 },
          { key: REDIS_CHANNEL, value: log_channel },
          { key: ZIPKIN_URL, value: http://zipkin:9411/api/v1/spans }
        ]
      }
    }
    components: [
      @PATH(./log-message-processor/main.py)
      struct LogProcessor {
        methods: [
          +log_message(message any) -> void,
          +http_transport(encoded_span any) -> void,
          +run(redis_host string, redis_port int, redis_channel string, zipkin_url string) -> void
        ]
      },
      @PATH(./log-message-processor/main.py)
      queue TodosLogChannelConsumer {
        engine: redis
        channel: log_channel
        direction: subscribe
        purpose: print messages to stdout
      }
    ]
  }

  @PATH(./)
  service zipkin {
    description: Zipkin tracing collector and UI
    langs: [container]
    runtime: {
      development: {
        backend: docker-compose
        image: openzipkin/zipkin
        ports_exposed: [9411]
      }

      @PATH(k8s/zipkin/deployment.yaml)
      @PATH(k8s/zipkin/service.yaml)
      kubernetes: {
        backend: k8s
        deployment_name: zipkin
        service_name: zipkin
        replicas: 1
        image: openzipkin/zipkin
        labels: {
          app: microservice-app-example
          service: zipkin
        }
        ports_exposed: [9411]
        service_type: LoadBalancer
      }
    }
  }

  @PATH(./)
  service redis_queue {
    description: Redis instance used as a queue for logging messages
    langs: [container]
    runtime: {
      development: {
        backend: docker-compose
        image: redis
      }

      @PATH(k8s/redis-queue/deployment.yaml)
      @PATH(k8s/redis-queue/service.yaml)
      kubernetes: {
        backend: k8s
        deployment_name: redis-queue
        service_name: redis-queue
        replicas: 1
        image: redis
        labels: {
          app: microservice-app-example
          service: redis-queue
        }
        ports_exposed: [6379]
      }
    }
    components: [
      queue LogChannel {
        engine: redis
        channel: log_channel
        publishers: [todos_api]
        subscribers: [log_message_processor]
      }
    ]
  }
}
